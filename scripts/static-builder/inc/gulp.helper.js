// Generated by CoffeeScript 1.12.7
var Helper,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Helper = {
  workFolder: './',
  htDocsFolder: 'htdocs',
  setHtDocsFolder: function(folder) {
    this.htDocsFolder = folder;
    return this;
  },
  getHtDocsFolder: function() {
    return this.htDocsFolder;
  },
  extend: function() {
    var i, j, key, ref;
    for (i = j = 1, ref = arguments.length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      for (key in arguments[i]) {
        if (arguments[i].hasOwnProperty(key)) {
          if (typeof arguments[0][key] === 'object' && typeof arguments[i][key] === 'object') {
            this.extend(arguments[0][key], arguments[i][key]);
          } else {
            arguments[0][key] = arguments[i][key];
          }
        }
      }
    }
    return arguments[0];
  },
  setWorkFolder: function(workFolder) {
    this.workFolder = workFolder;
    return this;
  },
  req: function(module) {
    return require(this.workFolder + '/node_modules/' + module);
  },
  getRootFolder: function() {
    return './';
  },
  getVersionFile: function() {
    return '../_cfg/lib/diStaticBuild.php';
  },
  fullPath: function(path) {
    var neg;
    neg = '';
    if (path.substr(0, 1) === '!') {
      neg = '!';
      path = path.substr(1);
    }
    return neg + this.getRootFolder() + path;
  },
  tryDone: function(tasksDone, tasksTotal, done) {
    if (tasksDone === tasksTotal) {
      done();
    }
    return this;
  },
  deleteFolderRecursive: function(folder, excludesList) {
    var fs, path;
    if (excludesList == null) {
      excludesList = [];
    }
    if (!fs) {
      fs = require('fs');
    }
    if (!path) {
      path = require('path');
    }
    if (fs.existsSync(folder)) {
      fs.readdirSync(folder).forEach((function(_this) {
        return function(file, index) {
          var curPath;
          curPath = path.join(folder + '/' + file);
          if (indexOf.call(excludesList, curPath) >= 0) {
            return;
          }
          if (fs.lstatSync(curPath).isDirectory()) {
            _this.deleteFolderRecursive(curPath);
          } else {
            fs.unlinkSync(curPath);
          }
        };
      })(this));
      fs.rmdirSync(folder);
    }
    return this;
  },
  copyCoreAssets: function(gulp, done) {
    console.log('Copying CSS');
    gulp.src(['../vendor/dimaninc/di_core/css/**/*']).pipe(gulp.dest('../' + this.getHtDocsFolder() + '/assets/styles/_core/'));
    console.log('Copying Fonts');
    gulp.src(['../vendor/dimaninc/di_core/fonts/**/*']).pipe(gulp.dest('../' + this.getHtDocsFolder() + '/assets/fonts/'));
    console.log('Copying Images');
    gulp.src(['../vendor/dimaninc/di_core/i/**/*']).pipe(gulp.dest('../' + this.getHtDocsFolder() + '/assets/images/_core/'));
    console.log('Copying JS');
    gulp.src(['../vendor/dimaninc/di_core/js/**/*']).pipe(gulp.dest('../' + this.getHtDocsFolder() + '/assets/js/_core/'));
    console.log('Copying Vendor libs');
    gulp.src(['../vendor/dimaninc/di_core/vendor/**/*']).pipe(gulp.dest('../' + this.getHtDocsFolder() + '/assets/vendor/'));
    done();
    return this;
  },
  getFolders: function() {
    return ['_admin/_inc/cache', '_cfg/cache', 'db/dump', this.getHtDocsFolder() + '/assets/fonts', this.getHtDocsFolder() + '/assets/images/_core', this.getHtDocsFolder() + '/assets/js/_core', this.getHtDocsFolder() + '/assets/styles/_core', this.getHtDocsFolder() + '/uploads', 'log', 'log/db', 'log/debug'];
  },
  createFolders: function(done) {
    var fn, folder, folders, j, len, mkdirp, tasksDone, tasksTotal;
    if (!mkdirp) {
      mkdirp = this.req('mkdirp');
    }
    folders = this.getFolders().map(function(f) {
      return '../' + f;
    });
    tasksTotal = folders.length;
    tasksDone = 0;
    fn = function(folder) {
      return mkdirp(folder, {
        mode: 0x1ff
      }, function(err) {
        if (err) {
          console.error(err);
        } else {
          console.log(folder, 'created');
        }
        return Helper.tryDone(++tasksDone, tasksTotal, done);
      });
    };
    for (j = 0, len = folders.length; j < len; j++) {
      folder = folders[j];
      fn(folder);
    }
    return this;
  },
  writeVersionFile: function() {
    var fs;
    if (!fs) {
      fs = require('fs');
    }
    fs.writeFileSync(this.getRootFolder() + this.getVersionFile(), '<?php\nclass diStaticBuild\n{\n    const VERSION = ' + (new Date()).getTime() + ';\n}');
    return this;
  },
  assignBasicTasksToGulp: function(gulp) {
    gulp.task('version', function(done) {
      Helper.writeVersionFile();
      return done();
    });
    gulp.task('create-folders', function(done) {
      return Helper.createFolders(done);
    });
    gulp.task('copy-core-assets', function(done) {
      return Helper.copyCoreAssets(gulp, done);
    });
    gulp.task('init', gulp.series('create-folders', 'copy-core-assets'));
    return this;
  },
  assignLessTaskToGulp: function(gulp, opts) {
    var less;
    if (opts == null) {
      opts = {};
    }
    if (!less) {
      less = this.req('gulp-less');
    }
    opts = this.extend({
      fn: null,
      buildFolder: null,
      taskName: 'less'
    }, opts);
    gulp.task(opts.taskName, (function(_this) {
      return function(done) {
        return gulp.src(_this.fullPath(opts.fn)).pipe(less()).on('error', console.log).pipe(gulp.dest(_this.fullPath(opts.buildFolder))).on('end', function() {
          return done();
        });
      };
    })(this));
    return this;
  },
  assignStylusTaskToGulp: function(gulp, opts) {
    var nib, stylus;
    if (opts == null) {
      opts = {};
    }
    if (!stylus) {
      stylus = this.req('gulp-stylus');
    }
    if (!nib) {
      nib = this.req('nib');
    }
    opts = this.extend({
      fn: null,
      buildFolder: null,
      taskName: 'stylus'
    }, opts);
    gulp.task(opts.taskName, (function(_this) {
      return function(done) {
        return gulp.src(_this.fullPath(opts.fn)).pipe(stylus({
          use: nib(),
          'include css': true
        })).on('error', console.log).pipe(gulp.dest(_this.fullPath(opts.buildFolder))).on('end', function() {
          return done();
        });
      };
    })(this));
    return this;
  },
  assignPngSpritesTaskToGulp: function(gulp, opts) {
    var spriteSmith;
    if (opts == null) {
      opts = {};
    }
    if (!spriteSmith) {
      spriteSmith = this.req('gulp.spritesmith');
    }
    opts = this.extend({
      mask: null,
      imgName: null,
      cssName: null,
      cssFormat: 'stylus',
      imgFolder: null,
      cssFolder: null,
      taskName: 'stylus-sprite'
    }, opts);
    gulp.task(opts.taskName, (function(_this) {
      return function(done) {
        var spriteData;
        spriteData = gulp.src(_this.fullPath(opts.mask)).pipe(spriteSmith({
          imgName: opts.imgName,
          cssName: opts.cssName,
          cssFormat: opts.cssFormat,
          algorithm: 'binary-tree',
          cssTemplate: function(data) {
            var item, j, len, ref, template, timestamp;
            timestamp = (new Date).getTime();
            template = "$sprite-timestamp = " + timestamp + "\n";
            ref = data.items;
            for (j = 0, len = ref.length; j < len; j++) {
              item = ref[j];
              template += "$sprite-" + item.name + " = " + item.px.offset_x + " " + item.px.offset_y + " " + item.px.width + " " + item.px.height + "\n";
            }
            return template;
          }
        })).on('error', console.log).on('end', function() {
          return done();
        });
        spriteData.img.pipe(gulp.dest(_this.fullPath(opts.imgFolder)));
        return spriteData.css.pipe(gulp.dest(_this.fullPath(opts.cssFolder)));
      };
    })(this));
    return this;
  },
  assignCssConcatTaskToGulp: function(gulp, opts) {
    var concat;
    if (opts == null) {
      opts = {};
    }
    if (!concat) {
      concat = this.req('gulp-concat');
    }
    opts = this.extend({
      files: [],
      output: null,
      taskName: 'css-concat'
    }, opts);
    gulp.task(opts.taskName, (function(_this) {
      return function(done) {
        return gulp.src(opts.files.map(function(f) {
          return _this.fullPath(f);
        })).pipe(concat(opts.output)).on('error', console.log).pipe(gulp.dest(_this.fullPath(_this.getRootFolder()))).on('end', function() {
          return done();
        });
      };
    })(this));
    return this;
  },
  cleanCoffeeBuildDirectory: function(folder) {
    this.deleteFolderRecursive(this.fullPath(folder));
    return this;
  },
  assignCoffeeTaskToGulp: function(gulp, opts) {
    var coffee;
    if (opts == null) {
      opts = {};
    }
    if (!coffee) {
      coffee = this.req('gulp-coffee');
    }
    opts = this.extend({
      folder: null,
      mask: null,
      jsBuildFolder: null,
      cleanBefore: false,
      taskName: 'coffee'
    }, opts);
    gulp.task(opts.taskName, (function(_this) {
      return function(done) {
        if (opts.cleanBefore) {
          _this.cleanCoffeeBuildDirectory(opts.jsBuildFolder);
        }
        return gulp.src(_this.fullPath(opts.folder + opts.mask)).pipe(coffee({
          bare: true
        })).pipe(gulp.dest(_this.fullPath(opts.jsBuildFolder))).on('end', function() {
          return done();
        });
      };
    })(this));
    return this;
  }
};

module.exports = Helper;

//# sourceMappingURL=gulp.helper.js.map
