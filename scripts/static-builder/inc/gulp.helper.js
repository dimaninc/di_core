// Generated by CoffeeScript 1.12.7
var Helper,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Helper = {
  workFolder: './',
  setWorkFolder: function(workFolder) {
    this.workFolder = workFolder;
    return this;
  },
  req: function(module) {
    return require(this.workFolder + '/node_modules/' + module);
  },
  getRootFolder: function() {
    return './';
  },
  getVersionFile: function() {
    return '../_cfg/lib/diStaticBuild.php';
  },
  fullPath: function(path) {
    var neg;
    neg = '';
    if (path.substr(0, 1) === '!') {
      neg = '!';
      path = path.substr(1);
    }
    return neg + this.getRootFolder() + path;
  },
  tryDone: function(tasksDone, tasksTotal, done) {
    if (tasksDone === tasksTotal) {
      done();
    }
    return this;
  },
  deleteFolderRecursive: function(folder, excludesList) {
    var fs, path;
    if (excludesList == null) {
      excludesList = [];
    }
    if (!fs) {
      fs = require('fs');
    }
    if (!path) {
      path = require('path');
    }
    if (fs.existsSync(folder)) {
      fs.readdirSync(folder).forEach(function(file, index) {
        var curPath;
        curPath = path.join(folder + '/' + file);
        if (indexOf.call(excludesList, curPath) >= 0) {
          return;
        }
        if (fs.lstatSync(curPath).isDirectory()) {
          deleteFolderRecursive(curPath);
        } else {
          fs.unlinkSync(curPath);
        }
      });
      fs.rmdirSync(folder);
    }
    return this;
  },
  copyCoreAssets: function(gulp, done) {
    console.log('Copying CSS');
    gulp.src(['../vendor/dimaninc/di_core/css/**/*']).pipe(gulp.dest('../htdocs/assets/styles/_core/'));
    console.log('Copying Fonts');
    gulp.src(['../vendor/dimaninc/di_core/fonts/**/*']).pipe(gulp.dest('../htdocs/assets/fonts/'));
    console.log('Copying Images');
    gulp.src(['../vendor/dimaninc/di_core/i/**/*']).pipe(gulp.dest('../htdocs/assets/images/_core/'));
    console.log('Copying JS');
    gulp.src(['../vendor/dimaninc/di_core/js/**/*']).pipe(gulp.dest('../htdocs/assets/js/_core/'));
    console.log('Copying Vendor libs');
    gulp.src(['../vendor/dimaninc/di_core/vendor/**/*']).pipe(gulp.dest('../htdocs/assets/vendor/'));
    done();
    return this;
  },
  getFolders: function() {
    return ['_admin/_inc/cache', '_cfg/cache', 'db/dump', 'htdocs/assets/fonts', 'htdocs/assets/images/_core', 'htdocs/assets/js/_core', 'htdocs/assets/styles/_core', 'htdocs/uploads', 'log', 'log/db', 'log/debug'];
  },
  createFolders: function(done) {
    var fn, folder, folders, i, len, mkdirp, tasksDone, tasksTotal;
    if (!mkdirp) {
      mkdirp = this.req('mkdirp');
    }
    folders = this.getFolders().map(function(f) {
      return '../' + f;
    });
    tasksTotal = folders.length;
    tasksDone = 0;
    fn = function(folder) {
      return mkdirp(folder, {
        mode: 0x1ff
      }, function(err) {
        if (err) {
          console.error(err);
        } else {
          console.log(folder, 'created');
        }
        return Helper.tryDone(++tasksDone, tasksTotal, done);
      });
    };
    for (i = 0, len = folders.length; i < len; i++) {
      folder = folders[i];
      fn(folder);
    }
    return this;
  },
  writeVersionFile: function() {
    var fs;
    if (!fs) {
      fs = require('fs');
    }
    fs.writeFileSync(this.getRootFolder() + this.getVersionFile(), '<?php\nclass diStaticBuild\n{\n    const VERSION = ' + (new Date()).getTime() + ';\n}');
    return this;
  },
  assignBasicTasksToGulp: function(gulp) {
    gulp.task('version', function(done) {
      Helper.writeVersionFile();
      return done();
    });
    gulp.task('create-folders', function(done) {
      return Helper.createFolders(done);
    });
    gulp.task('copy-core-assets', function(done) {
      return Helper.copyCoreAssets(gulp, done);
    });
    gulp.task('init', gulp.series('create-folders', 'copy-core-assets'));
    return this;
  },
  assignLessTaskToGulp: function(gulp, opts) {
    var less;
    if (opts == null) {
      opts = {
        fn: null,
        buildFolder: null
      };
    }
    if (!less) {
      less = this.req('gulp-less');
    }
    gulp.task('less', (function(_this) {
      return function(done) {
        return gulp.src(_this.fullPath(opts.fn)).pipe(less()).on('error', console.log).pipe(gulp.dest(_this.fullPath(opts.buildFolder))).on('end', function() {
          return done();
        });
      };
    })(this));
    return this;
  },
  assignStylusTaskToGulp: function(gulp, opts) {
    var nib, stylus;
    if (opts == null) {
      opts = {
        fn: null,
        buildFolder: null
      };
    }
    if (!stylus) {
      stylus = this.req('gulp-stylus');
    }
    if (!nib) {
      nib = this.req('nib');
    }
    gulp.task('stylus', (function(_this) {
      return function(done) {
        return gulp.src(_this.fullPath(opts.fn)).pipe(stylus({
          use: nib(),
          'include css': true
        })).on('error', console.log).pipe(gulp.dest(_this.fullPath(opts.buildFolder))).on('end', function() {
          return done();
        });
      };
    })(this));
    return this;
  },
  assignPngSpritesTaskToGulp: function(gulp, opts) {
    var spriteSmith;
    if (opts == null) {
      opts = {
        mask: null,
        imgName: null,
        cssName: null,
        cssFormat: 'stylus',
        imgFolder: null,
        cssFolder: null
      };
    }
    if (!spriteSmith) {
      spriteSmith = this.req('gulp.spritesmith');
    }
    gulp.task('stylus-sprite', (function(_this) {
      return function(done) {
        var spriteData;
        spriteData = gulp.src(_this.fullPath(opts.mask)).pipe(spriteSmith({
          imgName: opts.imgName,
          cssName: opts.cssName,
          cssFormat: opts.cssFormat,
          algorithm: 'binary-tree',
          cssTemplate: function(data) {
            var i, item, len, ref, template, timestamp;
            timestamp = (new Date).getTime();
            template = "$sprite-timestamp = " + timestamp + "\n";
            ref = data.items;
            for (i = 0, len = ref.length; i < len; i++) {
              item = ref[i];
              template += "$sprite-" + item.name + " = " + item.px.offset_x + " " + item.px.offset_y + " " + item.px.width + " " + item.px.height + "\n";
            }
            return template;
          }
        })).on('error', console.log).on('end', function() {
          return done();
        });
        spriteData.img.pipe(gulp.dest(_this.fullPath(opts.imgFolder)));
        return spriteData.css.pipe(gulp.dest(_this.fullPath(opts.cssFolder)));
      };
    })(this));
    return this;
  },
  assignCssConcatTaskToGulp: function(gulp, opts) {
    var concat;
    if (opts == null) {
      opts = {
        files: [],
        output: null
      };
    }
    if (!concat) {
      concat = this.req('gulp-concat');
    }
    gulp.task('css-concat', (function(_this) {
      return function(done) {
        return gulp.src(opts.files.map(function(f) {
          return _this.fullPath(f);
        })).pipe(concat(opts.output)).on('error', console.log).pipe(gulp.dest(_this.fullPath(_this.getRootFolder()))).on('end', function() {
          return done();
        });
      };
    })(this));
    return this;
  }
};

module.exports = Helper;

//# sourceMappingURL=gulp.helper.js.map
